"use strict";(self.webpackChunkumass_compsci_220_github_io=self.webpackChunkumass_compsci_220_github_io||[]).push([[6163],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,h=u["".concat(l,".").concat(d)]||u[d]||c[d]||s;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<s;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4215:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const s={sidebar_position:9},i="Building an Interpreter",o={unversionedId:"homework/building-an-interpreter",id:"homework/building-an-interpreter",title:"Building an Interpreter",description:"- Please download the homework from here",source:"@site/materials/homework/building-an-interpreter.md",sourceDirName:"homework",slug:"/homework/building-an-interpreter",permalink:"/materials/homework/building-an-interpreter",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Fetching and Web APIs",permalink:"/materials/homework/fetching-and-web-apis"},next:{title:"Discussion",permalink:"/materials/category/discussion"}},l={},p=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Student Expectations",id:"student-expectations",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Concrete Syntax",id:"concrete-syntax",level:3},{value:"Parser",id:"parser",level:3},{value:"State",id:"state",level:3},{value:"Behavior",id:"behavior",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Optional: Interpreting Functions",id:"optional-interpreting-functions",level:3},{value:"Programming Tasks",id:"programming-tasks",level:2},{value:"<code>interpExpression</code>",id:"interpexpression",level:3},{value:"<code>interpStatement</code>",id:"interpstatement",level:3},{value:"<code>interpProgram</code>",id:"interpprogram",level:3},{value:"Testing",id:"testing",level:2},{value:"Approach",id:"approach",level:3},{value:"How do I test what is printed to the console?",id:"how-do-i-test-what-is-printed-to-the-console",level:3},{value:"Capturing Errors",id:"capturing-errors",level:3}],m={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"building-an-interpreter"},"Building an Interpreter"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Please download the homework from ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/umass-compsci-220/public-materials/raw/main/homework/09-building-an-interpreter.zip"},"here"))),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"For this project, you will write an ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Interpreter_(computing)"},"interpreter")," for a small programming language similar to ",(0,r.kt)("strong",{parentName:"p"},"JavaScript (not TypeScript)"),". To write an interpreter, you need a parser (provided to you inside of ",(0,r.kt)("inlineCode",{parentName:"p"},"./include/parser.ts"),") to turn the program's concrete syntax (a string of characters) into an ",(0,r.kt)("em",{parentName:"p"},"abstract syntax tree"),". You will need to traverse the AST making necessary checks and executing corresponding statements and expressions."),(0,r.kt)("h3",{id:"learning-objectives"},"Learning Objectives"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Learn fundamentals of programming language implementation"),(0,r.kt)("li",{parentName:"ul"},"How to read the grammar for a concrete syntax"),(0,r.kt)("li",{parentName:"ul"},"How to work with and read abstract syntax trees")),(0,r.kt)("h3",{id:"student-expectations"},"Student Expectations"),(0,r.kt)("p",null,"Students will be graded on their ability to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Correctly implement the functions ",(0,r.kt)("a",{parentName:"li",href:"#programming-tasks"},"specified below")),(0,r.kt)("li",{parentName:"ul"},"Resolve all linter warnings"),(0,r.kt)("li",{parentName:"ul"},"Follow the ",(0,r.kt)("a",{parentName:"li",href:"/materials/guidelines/syntax-and-code"},"coding"),", ",(0,r.kt)("a",{parentName:"li",href:"/materials/guidelines/bad-practices"},"bad practice")," and ",(0,r.kt)("a",{parentName:"li",href:"/materials/guidelines/testing"},"testing")," guidelines"),(0,r.kt)("li",{parentName:"ul"},"Design full-coverage ",(0,r.kt)("a",{parentName:"li",href:"#testing"},"unit-tests")," for the functions they implemented",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"See the ",(0,r.kt)("a",{parentName:"li",href:"/materials/guidelines/testing#coverage"},"testing guidelines")," on coverage for more details")))),(0,r.kt)("h2",{id:"getting-started"},"Getting Started"),(0,r.kt)("h3",{id:"concrete-syntax"},"Concrete Syntax"),(0,r.kt)("p",null,"The following (simplified) grammar describes the concrete syntax of the fragment of JavaScript that you will be working with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},"Numbers        n ::= ...                    base-10 numbers\n\nVariables      x ::= ...                    variable name, a sequence of alphabetic letters\n\nExpressions    e ::= n                      numeric constant\n                | true                      boolean value true\n                | false                     boolean value false\n                | x                         variable reference\n                | e_1 + e_2                 addition\n                | e_1 - e_2                 subtraction\n                | e_1 * e_2                 multiplication\n                | e_1 / e_2                 division\n                | e_1 && e_2                logical AND\n                | e_1 || e_2                logical OR\n                | e_1 < e_2                 less than\n                | e_1 > e_2                 greater than\n                | e_1 === e_2               equal to\n\nStatements    s ::= let x = e;              variable declaration\n                  | x = e;                  assignment\n                  | if (e) b_1 else b_2     conditional\n                  | while (e) b             loop\n                  | print(e);               display to console\n\nBlocks        b ::= { s_1 ... s_n }\n\nPrograms      p ::= s_1 ... s_n\n")),(0,r.kt)("p",null,"Some nonterminals (like Numbers and Variables) have been described in words for simplicity. The actual grammar is defined inside of ",(0,r.kt)("inlineCode",{parentName:"p"},"./include/grammar.pegjs"),". You may take a look at it if you are curious, but you should not need to."),(0,r.kt)("p",null,"Each line of the grammar defines a rule. As an example, the rule"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},"Expressions   e ::= n                     numeric constant\n                  | true                  boolean value true\n                  | false                 boolean value false\n                  | e_1 + e_2             addition\n                  | e_1 && e_2            logical AND\n")),(0,r.kt)("p",null,"would read as: An expression, labeled as ",(0,r.kt)("inlineCode",{parentName:"p"},"e"),", may be one of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"n"),", a number (as defined above)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"true"),", the boolean value true"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"false"),", the boolean value false"),(0,r.kt)("li",{parentName:"ul"},"An expression, ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"e"),(0,r.kt)("mn",{parentName:"msub"},"1"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"e_1")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))))))),", a plus symbol, followed by another expression ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"e"),(0,r.kt)("mn",{parentName:"msub"},"2"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"e_2")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))))))),", for addition"),(0,r.kt)("li",{parentName:"ul"},"An expression, ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"e"),(0,r.kt)("mn",{parentName:"msub"},"1"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"e_1")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"1")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))))))),", two ampersands (",(0,r.kt)("inlineCode",{parentName:"li"},"&&"),"), followed by another expression ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("msub",{parentName:"mrow"},(0,r.kt)("mi",{parentName:"msub"},"e"),(0,r.kt)("mn",{parentName:"msub"},"2"))),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"e_2")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.3011em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))),(0,r.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.15em"}},(0,r.kt)("span",{parentName:"span"})))))))))),", for logical AND")),(0,r.kt)("h3",{id:"parser"},"Parser"),(0,r.kt)("p",null,"We have provided two parsing functions, defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"./include/parser.ts"),", the function ",(0,r.kt)("inlineCode",{parentName:"p"},"parseExpression")," parses an expression and the function ",(0,r.kt)("inlineCode",{parentName:"p"},"parseProgram")," parses a program (a series of statements). Their type signatures are outlined below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'type BinaryOperator = "+" | "-" | "*" | "/" | "&&" | "||" | ">" | "<" | "===";\n\ntype Expression =\n  | BooleanExpression\n  | NumberExpression\n  | VariableExpression\n  | BinaryOperatorExpression\n  \ntype BooleanExpression = { kind: "boolean"; value: boolean };\ntype NumberExpression = { kind: "number"; value: number };\ntype BinaryOperatorExpression = { kind: "operator"; operator: BinaryOperator; left: Expression; right: Expression };\ntype VariableExpression = { kind: "variable"; name: string };\n\ntype Statement =\n  | LetStatement\n  | AssignmentStatement\n  | IfStatement\n  | WhileStatement\n  | PrintStatement\n\ntype LetStatement = { kind: "let"; name: string; expression: Expression };\ntype AssignmentStatement = { kind: "assignment"; name: string; expression: Expression };\ntype IfStatement = { kind: "if"; test: Expression; truePart: Statement[]; falsePart: Statement[] };\ntype WhileStatement = { kind: "while"; test: Expression; body: Statement[] };\ntype PrintStatement = { kind: "print"; expression: Expression };\ntype ExpressionStatement = { kind: "expression"; expression: Expression };\ntype ReturnStatement = { kind: "return"; expression: Expression };\n\n\nfunction parseExpression(expression: string): Expression;\nfunction parseProgram(statements: string): Statement[];\n')),(0,r.kt)("p",null,"On success, these functions will return an object that contains the the corresponding abstract syntax tree (AST) for the given string. On failure, these functions throw an error with a reason: the string cannot be parsed."),(0,r.kt)("p",null,"Parsing and interpreting are separate stages of a programs execution. The interpreter depends on the parser to construct a valid AST. If the parser fails, then it is considered an unrecoverable failure and proceeding stages, such as interpreting (or linting/formatting if we were writing those tools), cannot run. ",(0,r.kt)("strong",{parentName:"p"},"You are not expected to cover input that the parser rejects.")),(0,r.kt)("h3",{id:"state"},"State"),(0,r.kt)("p",null,"Implement the State class with the following interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'class State {\n  // Add private member variables here\n\n  constructor(parent: State | undefined = undefined) {\n  }\n\n  // Declares a variable with the given name and binds\n  // the given value to it in the local scope.\n  // Throws an error if the name already exists in the innermost scope.\n  declare(name: string, value: RuntimeValue) {\n  }\n\n  // Returns the value bound to the given name in the current environment.\n  // The "environment" is the current collection of nested scopes.\n  // First searches the innermost scope, then checks each parent scope\n  // sequentially until the name is found.\n  // Throws an error if the name cannot be found.\n  get(name: string): RuntimeValue {\n  }\n\n  // Updates the value bound to the given name in the current environment.\n  // First searches the innermost scope, then checks each parent scope\n  // sequentially until the name is found.\n  // Throws an error if the name cannot be found.\n  set(name: string, value: RuntimeValue) {\n  }\n\n  // DO NOT MODIFY.\n  // This is present to help us test your code. \n  // If you remove it, this may cause tests to fail on the autograder.\n  // Returns an object containing the variable bindings of the innermost scope of this State.\n  asObject() {\n    return Object.fromEntries(this.vars.entries());\n  }\n}\n')),(0,r.kt)("p",null,"A block starts a new inner scope. A variable declared in a block will shadow an outer declaration (any variable use will refer to the inner declaration). On exiting a scope, variables declared there are no longer accessible (since we don't have closures). Thus, they should not be in the global state at the end. The nesting of block scopes corresponds to a stack, which you can implement as a linked list, by adding to your ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," object a link to an outer scope. Since the link is just another property, this allows all functions to keep their signatures. To ensure the link name does not clash with a program variable, use a property name that is not an identifier (see given: ",(0,r.kt)("inlineCode",{parentName:"p"},"PARENT_STATE_KEY"),"). The global state cannot have extra properties, and does not need a link, as the last state on the list."),(0,r.kt)("h3",{id:"behavior"},"Behavior"),(0,r.kt)("p",null,"The behavior of our interpreter should be similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"node"),' interpreter in "',(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode"},"strict mode"),'" (with some exceptions). To test what your interpreter should do in a scenario, you may use the ',(0,r.kt)("inlineCode",{parentName:"p"},"node --use-strict")," command in a terminal to open a Read Eval Print Loop (REPL). This interface will allow you to input statements and expressions and will display an error or the evaluated result."),(0,r.kt)("p",null,"Exceptions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Arithmetic and greater/less-than comparison may only happen between numbers")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Logical operations should ",(0,r.kt)("a",{parentName:"em",href:"https://en.wikipedia.org/wiki/Short-circuit_evaluation"},"short-circuit"),". Evaluated operands must be boolean values")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Division by zero is forbidden")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Additional checks to emulate ",(0,r.kt)("inlineCode",{parentName:"em"},"ReferenceError")," behavior are unneeded"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This would require an additional pass prior to interpreting to ensure variables are not used before declaration"),(0,r.kt)("li",{parentName:"ul"},"See ",(0,r.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting"},"MDN on Hoisting")," if you are curious")))),(0,r.kt)("h3",{id:"error-handling"},"Error Handling"),(0,r.kt)("p",null,"An interpreter can generally not continue meaningfully after an error (as opposed to compilers). Thus, if you find an error, ",(0,r.kt)("strong",{parentName:"p"},'you should throw an error, using an informative error message (i.e. "Arithmetic may only happen between numbers")'),". You need to do a number of checks (e.g., correct typing, and missing or duplicate declarations)."),(0,r.kt)("h3",{id:"optional-interpreting-functions"},"Optional: Interpreting Functions"),(0,r.kt)("p",null,"As extra (uncredited) practice, you can implement first-class functions inside of your interpreter. We will extend the grammar to include function expressions, call expressions, return statements, and expression statements (",(0,r.kt)("inlineCode",{parentName:"p"},"1 + 1;"),") - to support both ",(0,r.kt)("inlineCode",{parentName:"p"},"f();")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"f(g());"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},"e ::=\n    ...\n    | function (x1 ... xn ) b   Function expressions\n    | x(e1 ... en )             Call expression\n\ns ::=\n    ...\n    | e;                        Expression statements\n    | return e;                 Return statements\n")),(0,r.kt)("p",null,"The parser already supports these constructs. You may look at types inside ",(0,r.kt)("inlineCode",{parentName:"p"},"./include/parser.ts"),". Here are some hints for what needs to be updated in ",(0,r.kt)("inlineCode",{parentName:"p"},"./src/interpreter.ts"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add a new type of ",(0,r.kt)("inlineCode",{parentName:"li"},"RuntimeValue")," to support functions/closures",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Define an ",(0,r.kt)("inlineCode",{parentName:"li"},"interface")," with the values you might think you'd need"))),(0,r.kt)("li",{parentName:"ul"},"Give ",(0,r.kt)("inlineCode",{parentName:"li"},"interpStatement")," a return type other than ",(0,r.kt)("inlineCode",{parentName:"li"},"void"))),(0,r.kt)("p",null,"Rules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"A function's body is only evaluated when called")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Functions capture the environment they were created in")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"There may not be duplicate parameter names")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Providing more, or fewer, arguments than there are parameters is considered a runtime error")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"All functions must explicitly return a value (number, boolean, or another function)"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If a function has not explicitly returned after executing its body it is a runtime error")))),(0,r.kt)("h2",{id:"programming-tasks"},"Programming Tasks"),(0,r.kt)("p",null,"Your task is to implement the following functions inside of ",(0,r.kt)("inlineCode",{parentName:"p"},"./src/interpreter.ts"),". You may do them in any order. Reviewing lecture slides might be helpful."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"You may not use ",(0,r.kt)("inlineCode",{parentName:"strong"},"eval")," or anything similar (",(0,r.kt)("inlineCode",{parentName:"strong"},"new Function(...)"),").")),(0,r.kt)("p",null,"In general, your implementation should use helper functions corresponding to the different kinds of ",(0,r.kt)("inlineCode",{parentName:"p"},"Expression"),"s and ",(0,r.kt)("inlineCode",{parentName:"p"},"Statement"),"s defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"include/parser.ts"),".\nWithin those functions, you may use a combination of ",(0,r.kt)("inlineCode",{parentName:"p"},"switch")," statements, ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),"s of operators to functions, and regular conditional statements."),(0,r.kt)("p",null,"When using ",(0,r.kt)("inlineCode",{parentName:"p"},"switch")," statements, each case of the switch should be either a single call to a helper function or a single ",(0,r.kt)("strong",{parentName:"p"},"simple")," statement.\nThat is, ",(0,r.kt)("strong",{parentName:"p"},"do NOT cram compound statements such as ",(0,r.kt)("inlineCode",{parentName:"strong"},"if"),"s or ",(0,r.kt)("inlineCode",{parentName:"strong"},"while"),"s onto a single line"),".\nThat makes the code more dense and harder to understand."),(0,r.kt)("h3",{id:"interpexpression"},(0,r.kt)("inlineCode",{parentName:"h3"},"interpExpression")),(0,r.kt)("p",null,"Given a state object and an AST of an expression, ",(0,r.kt)("inlineCode",{parentName:"p"},"interpExpression")," evaluates the expression and returns its result. It should throw an error if the expression is invalid. See ",(0,r.kt)("a",{parentName:"p",href:"#behavior"},"Behavior")," and ",(0,r.kt)("a",{parentName:"p",href:"#error-handling"},"Error Handling"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function interpExpression(state: State, e: Expression): RuntimeValue {\n  // TODO\n}\n")),(0,r.kt)("h3",{id:"interpstatement"},(0,r.kt)("inlineCode",{parentName:"h3"},"interpStatement")),(0,r.kt)("p",null,"Given a state object and an AST of a statement, ",(0,r.kt)("inlineCode",{parentName:"p"},"interpStatement")," updates the ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," object. It should throw an error if the statement is invalid. See ",(0,r.kt)("a",{parentName:"p",href:"#behavior"},"Behavior")," and ",(0,r.kt)("a",{parentName:"p",href:"#error-handling"},"Error Handling"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function interpStatement(state: State, p: Statement): void {\n  // TODO\n}\n")),(0,r.kt)("h3",{id:"interpprogram"},(0,r.kt)("inlineCode",{parentName:"h3"},"interpProgram")),(0,r.kt)("p",null,"Given the AST of a program, ",(0,r.kt)("inlineCode",{parentName:"p"},"interpProgram")," returns the final state of the program. It should throw an error if any statement or expression is invalid. See ",(0,r.kt)("a",{parentName:"p",href:"#behavior"},"Behavior")," and ",(0,r.kt)("a",{parentName:"p",href:"#error-handling"},"Error Handling"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function interpProgram(p: Statement[]): State {\n  // TODO\n}\n")),(0,r.kt)("h2",{id:"testing"},"Testing"),(0,r.kt)("h3",{id:"approach"},"Approach"),(0,r.kt)("p",null,"Implement ",(0,r.kt)("inlineCode",{parentName:"p"},"interpExpression"),", following the template shown in class. You can use an empty object (",(0,r.kt)("inlineCode",{parentName:"p"},"{ }"),") for the state if you do not have any variables, or you can set the values of variables by hand. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'describe("interpExpression", () => {\n  it("evaluates multiplication with a variable", () => {\n    const r = interpExpression({ x: 10 }, parseExpression("x * 2"));\n\n    expect(r).toBe(20);\n  });\n});\n')),(0,r.kt)("p",null,"Implement ",(0,r.kt)("inlineCode",{parentName:"p"},"interpStatement")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"interpProgram"),", following the template shown in class. You should be able to test that assignment updates variables. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'describe("interpProgram", () => {\n  it("handles declarations and reassignment", () => {\n    const st = interpProgram(parseProgram("let x = 10; x = 20;"));\n\n    expect(st).toEqual({ x: 20 });\n  });\n});\n')),(0,r.kt)("p",null,"Finally, test your interpreter with some simple programs. For example, you should be able to interpret an iterative factorial or Fibonacci sequence computation."),(0,r.kt)("h3",{id:"how-do-i-test-what-is-printed-to-the-console"},"How do I test what is printed to the console?"),(0,r.kt)("p",null,"This can be done with mock testing.\nHere is an example of how to mock test console.log with the built-in Jest functionality."),(0,r.kt)("p",null,'describe("Tests for myFunc", () => {\nit("Checking what is printed", () => {\nconst logSpy = jest.spyOn(global.console, "log"); // Setup console to be mocked'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'const input = `someInput`;\n\nmyFunc(input); // In this example we expect console.log to print twice\nexpect(logSpy.mock.calls).toEqual([["First printed value"],["Second printed value"]]);\n\nlogSpy.mockRestore(); // Restore console.log to normal functionality\n')),(0,r.kt)("p",null,"  });"),(0,r.kt)("h3",{id:"capturing-errors"},"Capturing Errors"),(0,r.kt)("p",null,"You may find yourself in a scenario where you need to write a test that verifies a program throws an error. Here is an example of how you would write a test like that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function sqrt(n: number): number {\n  if (n < 0) throw new Error("Input must be positive or zero.");\n\n  // Do some iterations of Newton\'s method\n}\n\ntest("sqrt fails on invalid input", () => {\n  // Must pass a function, otherwise the error will not be captured and the test will fail\n  expect(() => {\n    sqrt(-1);\n  }).toThrow();\n});\n')),(0,r.kt)("p",null,"You can read more on the ",(0,r.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/expect#tothrowerror"},"Jest documentation on ",(0,r.kt)("inlineCode",{parentName:"a"},".toThrow()")),"."))}c.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkumass_compsci_220_github_io=self.webpackChunkumass_compsci_220_github_io||[]).push([[8411],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),d=i,f=p["".concat(l,".").concat(d)]||p[d]||m[d]||r;return n?a.createElement(f,o(o({ref:t},u),{},{components:n})):a.createElement(f,o({ref:t},u))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},227:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:3},o="Mental Models in JavaScript",s={unversionedId:"resources/mental-models",id:"resources/mental-models",title:"Mental Models in JavaScript",description:"This primer explains key mental models when working with JavaScript, focusing on object references, value assignments, and how JavaScript handles data when passed into functions.",source:"@site/materials/resources/mental-models.md",sourceDirName:"resources",slug:"/resources/mental-models",permalink:"/materials/resources/mental-models",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"External Content",permalink:"/materials/resources/external-content"},next:{title:"Tutorials",permalink:"/materials/category/tutorials"}},l={},c=[{value:"1. Objects and References",id:"1-objects-and-references",level:2},{value:"2. Assignment by Value",id:"2-assignment-by-value",level:2},{value:"3. Function Behavior with Objects",id:"3-function-behavior-with-objects",level:2},{value:"4. Functions as First-Class Citizens",id:"4-functions-as-first-class-citizens",level:2},{value:"5. Higher-Order Functions",id:"5-higher-order-functions",level:2},{value:"6. Closures and Scope",id:"6-closures-and-scope",level:2},{value:"7. Avoiding Recomputation with Closures",id:"7-avoiding-recomputation-with-closures",level:2},{value:"8. IIFE (Immediately Invoked Function Expressions)",id:"8-iife-immediately-invoked-function-expressions",level:2},{value:"9. Lexical Scope",id:"9-lexical-scope",level:2}],u={toc:c},p="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"mental-models-in-javascript"},"Mental Models in JavaScript"),(0,i.kt)("p",null,"This primer explains key mental models when working with JavaScript, focusing on object references, value assignments, and how JavaScript handles data when passed into functions."),(0,i.kt)("h2",{id:"1-objects-and-references"},"1. Objects and References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Object References"),": In JavaScript, objects are stored by reference (i.e., memory addresses). This means when we assign an object to a variable, we\u2019re assigning a reference, not a copy of the object."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let o = { x: 10, y: 2 };\nconst p = o;\no = 17;\nconsole.log(p.x); // Output: 10\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Here, ",(0,i.kt)("inlineCode",{parentName:"li"},"p")," initially references ",(0,i.kt)("inlineCode",{parentName:"li"},"o"),", but when ",(0,i.kt)("inlineCode",{parentName:"li"},"o")," is reassigned, ",(0,i.kt)("inlineCode",{parentName:"li"},"p")," retains the original object reference.")))),(0,i.kt)("iframe",{src:"/html/mental-models/ex1.html",width:"100%",height:"385px"}),(0,i.kt)("h2",{id:"2-assignment-by-value"},"2. Assignment by Value"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Value Assignment"),": All JavaScript variables, including those referencing objects, are assigned by value. This includes primitive data types (numbers, strings) as well as object references."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let x = 1;\nfunction reassignNumber(x) {\n  x = 5;\n  console.log(x); // Output: 5\n}\nreassignNumber(x);\nconsole.log(x); // Output: 1\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The function ",(0,i.kt)("inlineCode",{parentName:"li"},"reassignNumber")," doesn\u2019t affect the original ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," since only the value is passed into the function.")))),(0,i.kt)("iframe",{src:"/html/mental-models/ex1.html",width:"100%",height:"385px"}),(0,i.kt)("h2",{id:"3-function-behavior-with-objects"},"3. Function Behavior with Objects"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"No Pass by Reference"),": JavaScript does not support pass-by-reference, even for objects. However, when passing an object into a function, JavaScript passes the reference (address), so modifying the object within the function affects the original object."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let obj = { y: 1 };\nfunction reassignObjVal(inputObj) {\n  inputObj.y = 5;\n  console.log(inputObj.y); // Output: 5\n}\nreassignObjVal(obj);\nconsole.log(obj.y); // Output: 5\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Here, ",(0,i.kt)("inlineCode",{parentName:"li"},"inputObj")," is a reference to ",(0,i.kt)("inlineCode",{parentName:"li"},"obj"),". Changing ",(0,i.kt)("inlineCode",{parentName:"li"},"inputObj.y")," inside the function affects ",(0,i.kt)("inlineCode",{parentName:"li"},"obj"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Reassignment vs. Modification"),": Assigning a new value to an object parameter within a function does not affect the original object. Modifying the properties of the passed object does."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let obj = { y: 1 };\nfunction reassignObj(obj) {\n  obj = { y: 5 };\n  console.log(obj.y); // Output: 5\n}\nreassignObj(obj);\nconsole.log(obj.y); // Output: 1\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Although ",(0,i.kt)("inlineCode",{parentName:"li"},"obj")," is assigned a new object inside the function, the original ",(0,i.kt)("inlineCode",{parentName:"li"},"obj")," remains unchanged outside.")))),(0,i.kt)("p",null,'These mental models clarify how JavaScript handles objects and functions, reinforcing that objects are not "special" when it comes to passing by value.'),(0,i.kt)("iframe",{src:"/html/mental-models/ex3.html",width:"100%",height:"430px"}),(0,i.kt)("h2",{id:"4-functions-as-first-class-citizens"},"4. Functions as First-Class Citizens"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Functions as Values"),": In JavaScript, functions are treated as first-class citizens, meaning they can be assigned to variables, passed as arguments, or returned from other functions."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const greet = function(name) {\n  return `Hello, ${name}!`;\n};\nconsole.log(greet("Alice")); // Output: "Hello, Alice!"\n')),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Here, ",(0,i.kt)("inlineCode",{parentName:"li"},"greet")," is a function expression assigned to a variable, demonstrating that functions can be stored like any other value.")))),(0,i.kt)("iframe",{src:"/html/mental-models/ex4.html",width:"100%",height:"430px"}),(0,i.kt)("h2",{id:"5-higher-order-functions"},"5. Higher-Order Functions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Higher-Order Functions"),": These are functions that take other functions as arguments or return functions as results. Higher-order functions enable JavaScript's functional programming capabilities."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function multiplyBy(factor) {\n  return function(number) {\n    return number * factor;\n  };\n}\nconst double = multiplyBy(2);\nconsole.log(double(5)); // Output: 10\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"multiplyBy")," returns a new function, ",(0,i.kt)("inlineCode",{parentName:"li"},"double"),", which maintains the context of ",(0,i.kt)("inlineCode",{parentName:"li"},"factor")," from its original scope.")))),(0,i.kt)("iframe",{src:"/html/mental-models/ex5.html",width:"100%",height:"400px"}),(0,i.kt)("h2",{id:"6-closures-and-scope"},"6. Closures and Scope"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Closures"),": A closure occurs when an inner function remembers variables from its outer function, even after the outer function has finished executing. Closures are powerful for creating private variables and for optimizing computation by remembering past results."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function createCounter() {\n  let count = 0;\n  return function() {\n    count += 1;\n    return count;\n  };\n}\nconst counter = createCounter();\nconsole.log(counter()); // Output: 1\nconsole.log(counter()); // Output: 2\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"createCounter")," function returns an inner function that retains access to ",(0,i.kt)("inlineCode",{parentName:"li"},"count"),", creating a persistent scope for ",(0,i.kt)("inlineCode",{parentName:"li"},"count")," across calls.")))),(0,i.kt)("iframe",{src:"/html/mental-models/ex6.html",width:"100%",height:"490px"}),(0,i.kt)("h2",{id:"7-avoiding-recomputation-with-closures"},"7. Avoiding Recomputation with Closures"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Closure-Based Caching"),": Closures can be used to avoid recomputation by \u201cremembering\u201d previous values without explicitly memoizing. This is particularly useful for mathematical sequences or operations that may otherwise require recalculation."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"function fibonacci() {\n  let memo = { 0: 0, 1: 1 };\n  return function(n) {\n    if (n in memo) return memo[n];\n    memo[n] = fibonacci()(n - 1) + fibonacci()(n - 2);\n    return memo[n];\n  };\n}\nconst fib = fibonacci();\nconsole.log(fib(5)); // Output: 5\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Here, ",(0,i.kt)("inlineCode",{parentName:"li"},"memo")," is closed over by the inner function to store previously calculated Fibonacci numbers, which prevents redundant calculations.")))),(0,i.kt)("iframe",{src:"/html/mental-models/ex7.html",width:"100%",height:"530px"}),(0,i.kt)("h2",{id:"8-iife-immediately-invoked-function-expressions"},"8. IIFE (Immediately Invoked Function Expressions)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"IIFE"),": An Immediately Invoked Function Expression (IIFE) is a function that is executed right after it is defined. IIFEs are useful for creating isolated scopes, often to avoid variable pollution."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'(function() {\n  const secret = "I\'m a secret!";\n  console.log(secret); // Output: "I\'m a secret!"\n})();\n// console.log(secret); // Error: secret is not defined\n')),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Here, ",(0,i.kt)("inlineCode",{parentName:"li"},"secret")," is only accessible within the IIFE and does not leak into the surrounding scope.")))),(0,i.kt)("iframe",{src:"/html/mental-models/ex8.html",width:"100%",height:"370px"}),(0,i.kt)("h2",{id:"9-lexical-scope"},"9. Lexical Scope"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Lexical (Static) Scope"),": JavaScript uses lexical scoping, meaning that a function\u2019s scope is determined by its location within the code. Variables defined in an outer scope are accessible to inner functions, but not vice versa."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'function outer() {\n  const outerVar = "I\'m outside!";\n  function inner() {\n    console.log(outerVar);\n  }\n  inner(); // Output: "I\'m outside!"\n}\nouter();\n')),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"inner")," can access ",(0,i.kt)("inlineCode",{parentName:"li"},"outerVar")," because it is lexically within the ",(0,i.kt)("inlineCode",{parentName:"li"},"outer")," function scope, reinforcing predictable scoping rules.")))),(0,i.kt)("iframe",{src:"/html/mental-models/ex9.html",width:"100%",height:"530px"}))}m.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkumass_compsci_220_github_io=self.webpackChunkumass_compsci_220_github_io||[]).push([[8283],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(t),h=r,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||o;return t?a.createElement(m,i(i({ref:n},c),{},{components:t})):a.createElement(m,i({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},6832:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=t(7462),r=(t(7294),t(3905));const o={sidebar_position:1},i="Bad Practices",s={unversionedId:"guidelines/bad-practices",id:"guidelines/bad-practices",title:"Bad Practices",description:"This page lists common programming patterns that should be avoided. Failing to avoid this practices may result in point deductions on exams or homework assignments.",source:"@site/materials/guidelines/bad-practices.md",sourceDirName:"guidelines",slug:"/guidelines/bad-practices",permalink:"/materials/guidelines/bad-practices",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Guidelines",permalink:"/materials/category/guidelines"},next:{title:"Syntax and Code",permalink:"/materials/guidelines/syntax-and-code"}},l={},u=[{value:"Defining Mutable Unchanged Variables",id:"defining-mutable-unchanged-variables",level:2},{value:"Declaring Variables in the Wrong Scope",id:"declaring-variables-in-the-wrong-scope",level:2},{value:"Declaring Variables Far From Relevant Use",id:"declaring-variables-far-from-relevant-use",level:2},{value:"Writing Unnecessary Return Checks",id:"writing-unnecessary-return-checks",level:2},{value:"Creating Redundant Conditions and Branches",id:"creating-redundant-conditions-and-branches",level:2},{value:"Comparing Against Boolean Literals",id:"comparing-against-boolean-literals",level:2},{value:"Using Suboptimal Control Structures",id:"using-suboptimal-control-structures",level:2},{value:"Conditionals",id:"conditionals",level:3},{value:"Loops",id:"loops",level:3},{value:"Using Magical Values",id:"using-magical-values",level:2}],c={toc:u},d="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"bad-practices"},"Bad Practices"),(0,r.kt)("p",null,"This page lists common programming patterns that should be avoided. Failing to avoid this practices may result in point deductions on exams or homework assignments."),(0,r.kt)("p",null,"These guidelines are here to make you a better programmer. Avoiding these devices will help you write more clean, readable, and correct code. It is okay to ignore cleanliness and use these anti-patterns to get a working solution. But afterwords, you should go back and clean-up your code."),(0,r.kt)("h2",{id:"defining-mutable-unchanged-variables"},"Defining Mutable Unchanged Variables"),(0,r.kt)("p",null,"Mutability is defined as:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The characteristic of an object having properties whose values can change while the object itself maintains a unique identity.")),(0,r.kt)("p",null,"A variable can be mutable or immutable (able or unable to change; ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," vs ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),"). The majority of the time we use variables to store intermediate values, repeated expressions, or the results of a function call. These variables have names (identifiers) that are bound to these values. More often than not, we intend for these names to pertain to a single value for their entire lifetime."),(0,r.kt)("p",null,"When declaring a variable, we should default to using ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," rather than ",(0,r.kt)("inlineCode",{parentName:"p"},"let"),". This helps readers understand our code better and protects us, the authors, from accidentally updating a value we did not intend to."),(0,r.kt)("p",null,"Instead of:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let PI = 3.14;\nlet arr = [1, 2, 3];\nlet result = myFunction();\n")),(0,r.kt)("p",null,"Try:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const PI = 3.14;\nconst arr = [1, 2, 3];\nconst result = myFunction();\n")),(0,r.kt)("p",null,"A common misunderstanding is that ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," makes objects (arrays, maps, sets, plain objects) unable to change. ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),' applies to the variable name, not the value associated with that variable. It is a statement that says: "this name will always hold this value". Objects are stored through a reference (distinct from the value), and thus through that reference, we can change the state of an object, even if there is a variable defined with ',(0,r.kt)("inlineCode",{parentName:"p"},"const")," that holds the reference."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const obj = { x: 1 };\n\nobj.x = 1; // Completely valid\n")),(0,r.kt)("h2",{id:"declaring-variables-in-the-wrong-scope"},"Declaring Variables in the Wrong Scope"),(0,r.kt)("p",null,"In older versions of the C programming language (ANSI C89), variable declarations had to be at the top of the function definition. Otherwise, it would be a compile error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"int do_work() {\n  int i = 0;\n  int x = 0\n  int y = 0;\n\n  for (i = 0; i < 5; i++) {\n    x = i % 2; // x is only ever used in this scope,\n    // but is declared at the top of the function\n\n    if (x != 0) {\n      y += x;\n    }\n  }\n\n  return y;\n}\n")),(0,r.kt)("p",null,"However, JS/TS is not 1989 C, make use of your scopes, and isolate variables relevant to them inside."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function doWork() {\n  let y = 0; // y can be seen in the entire function\n  for (let i = 0; i < 5; i++) {\n    // i can only be seen in the loop\n    const x = i % 2; // x can only be seen in the loop\n    if (x !== 0) {\n      y += x;\n    }\n  }\n\n  return y;\n}\n")),(0,r.kt)("h2",{id:"declaring-variables-far-from-relevant-use"},"Declaring Variables Far From Relevant Use"),(0,r.kt)("p",null,"Consider the following example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let foo = 0; // foo defined with a meaningless value\n\nlet hcf; /* A bunch of code that is irrelevant to foo */\nfor (let i = 1; i <= number1 && i <= number2; i++) {\n  if (number1 % i == 0 && number2 % i == 0) {\n    hcf = i;\n  }\n}\n/* End of irrelevant code */\n\nfoo = baz(hcf); // relevant use of foo far from its definition\nif (foo >= 6) {\n  // body\n}\n")),(0,r.kt)("p",null,"A variable should be initialized directly to a meaningful and useful value. This should happen as close as possible to its use. Here, the initialization does not affect the later computation, which overwrites the value. The reader is misled and must analyze the first assignment, only to conclude that it serves no purpose. Useless code should be eliminated."),(0,r.kt)("h2",{id:"writing-unnecessary-return-checks"},"Writing Unnecessary Return Checks"),(0,r.kt)("p",null,"Sometimes you might want to write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function foo() {\n  if ( /* case 1 */ ) {\n    return true;\n  }\n  if ( /* case 2 */ ) {\n    return true\n  }\n}\n\n// or\n\nfunction foo() {\n  if ( /* case 1 */ ) {\n    return true;\n  } else { // case 2 is the logical opposite of case 1\n    return false;\n  }\n}\n")),(0,r.kt)("p",null,"Here we are asking a question, then if that question results in ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", returning ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," - otherwise returning ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". Our question (",(0,r.kt)("inlineCode",{parentName:"p"},"case 1"),") will probably",(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," only ever evaluate as ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". Checking what the result is, then immediately returning that result, is redundant. Try this instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function foo() {\n  return ( /* case 1 */ ) || ( /* case 2 */ );\n}\n\n// or\n\nfunction foo() {\n  return /* case 1 */;\n}\n")),(0,r.kt)("p",null,"This also applies to function calls:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function foo(): boolean {}\n\nfunction bar() {\n  if (foo()) {\n    // BAD\n    return true;\n  }\n\n  return foo(); // GOOD\n}\n")),(0,r.kt)("p",null,(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," If you find yourself in a case where you have an expression, that you just want to check if it ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Glossary/Truthy"},"truthy"),", you can use the ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"},(0,r.kt)("inlineCode",{parentName:"a"},"Boolean")," function"),"."),(0,r.kt)("h2",{id:"creating-redundant-conditions-and-branches"},"Creating Redundant Conditions and Branches"),(0,r.kt)("p",null,"This code snippet has two independent branches. A reader will analyze 2 x 2 = 4 possibilities - each branch being executed or not."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let foo: boolean;\n\n// First case\nif (foo) {\n  // body 1\n}\nif (!foo) {\n  // body 2\n}\n\n// Second case\nif (foo) {\n  // body 1\n} else if (!foo) {\n  // body 2\n}\n")),(0,r.kt)("p",null,"In the first case, it is likely that ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," is not changed in ",(0,r.kt)("inlineCode",{parentName:"p"},"body 1"),". So checking ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," again is redundant. The second case is similar, the first condition tests ",(0,r.kt)("inlineCode",{parentName:"p"},"foo"),", if the second condition were to execute, it would have already been established that ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," is not true."),(0,r.kt)("p",null,"Thus the intent of these two blocks is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"if (foo) {\n  // body 1\n} else {\n  // body 2\n}\n")),(0,r.kt)("p",null,"This is a lot easier to understand as a reader. ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," is a boolean, there is no need to have another check, if ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," was not true, then it has to be false."),(0,r.kt)("h2",{id:"comparing-against-boolean-literals"},"Comparing Against Boolean Literals"),(0,r.kt)("p",null,"Sometimes you might want to write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let y = 4;\nlet x = 3;\n\nif ((y < 4 || x < 5) === true) {\n}\n")),(0,r.kt)("p",null,"However, both sides of the ",(0,r.kt)("inlineCode",{parentName:"p"},"===")," operator are expressions and will be evaluated when the program runs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// 0 Start\nif ((y < 4 || x < 5) === true) {\n  // body\n}\n// 1 Evaluate both side of ||\nif ((false || true) === true) {\n  // body\n}\n// 2 Evaluate ||\nif (true === true) {\n  // body\n}\n// 3 Evaluate ===\nif (true) {\n  // body\n}\n// 4 Is "true" truthy? Yes -> Evaluate body. No -> Skip if-statement.\nif (true) {\n  /* Control goes here */\n}\n')),(0,r.kt)("p",null,"But the 3rd step is unnecessary. As the 4th step already checks to see if the result of the if-condition, and we only care about the left side of the ",(0,r.kt)("inlineCode",{parentName:"p"},"==="),". Instead, remove the unnecessary comparison."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"if (y < 4 || x < 5) {\n  // body\n}\n")),(0,r.kt)("p",null,"This also applies to functions that return boolean values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function hasPermission(user: User): boolean {}\n\nif (hasPermission(/* some value */) === true) // BAD\nif (hasPermission(/* some value */)) // GOOD\n")),(0,r.kt)("h2",{id:"using-suboptimal-control-structures"},"Using Suboptimal Control Structures"),(0,r.kt)("p",null,"Control structures are the syntactic devices we use to manipulate where the ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Control_flow"},"flow of control")," goes. This includes if-statements, ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator"},"ternary operators"),", loops (for, while, do-while), switch-statements and others. It is important to be mindful of which structure (or no structure) should be used to solve a problem. You are the architect of a program. Do not waste your time and effort using the suboptimal solution to a problem."),(0,r.kt)("h3",{id:"conditionals"},"Conditionals"),(0,r.kt)("p",null,"Simple if-statements can be replaced with ternary operators."),(0,r.kt)("p",null,"Instead of:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let x;\nif (/* some condition */) {\n  x = 5;\n} else {\n  x = 10;\n}\n\n// or\n\nif (/* some condition */) {\n  return 5;\n} else {\n  return 10;\n}\n")),(0,r.kt)("p",null,"Try:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let x = (/* some condition */) ? 5 : 10;\n\n// or\n\nreturn (/* some condition */) ? 5 : 10;\n")),(0,r.kt)("h3",{id:"loops"},"Loops"),(0,r.kt)("p",null,"If you need to iterate across a range of numbers, use a numeric for-loop. If the list of values is quite small (or specific), you could use ",(0,r.kt)("inlineCode",{parentName:"p"},"forEach")," on an array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"for (let i = 0; i < 10; i++) {}\n\n[2, 4, 6].forEach(n => {\n  /* code with element n */\n});\n")),(0,r.kt)("p",null,"for-of loops are similar to the for-each loops in Java. They will iterate over the values of an array (or any iterable object). Be cautious of for-in loops. They will iterate over the indices of an object/array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const arr = ["how", "are", "you"];\nfor (const element of arr) {\n  // code with element\n  console.log(element);\n}\n// -> how\n// -> are\n// -> you\n\nfor (const [index, element] of arr.entries()) {\n  // arr.entries return an iterator that will return the pairs [0, arr[0]], [1, arr[1]], ...\n  // code with both element and index\n  console.log(`${index} -> ${element}`);\n}\n// 0 -> "how"\n// 1 -> "are"\n// 2 -> "you"\n')),(0,r.kt)("p",null,"Or even better, use a ",(0,r.kt)("inlineCode",{parentName:"p"},"forEach")," if you are using an array (or write a ",(0,r.kt)("inlineCode",{parentName:"p"},"forEach")," for other data structures if needed). If you choose to use this interface, it might be best to avoid modifying the array or any outside variables."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"arr.forEach((element, i) => /* code with element and index i */);\n")),(0,r.kt)("h2",{id:"using-magical-values"},"Using Magical Values"),(0,r.kt)("p",null,"Magical constant values that appear inside your code are confusing to read and hard to change. Try and make it easier for your future self when they need to be updated."),(0,r.kt)("p",null,"Instead of this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function isAdmin(userId: string) {\n  return ["0", "7365420", "257342015"].includes(userId);\n}\n\n// Duration of 24 hours in milliseconds\nconst oneDay = 86400000;\n')),(0,r.kt)("p",null,"Try this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// Using a \'const-assertion\' (as const) to tell the compiler we do not want\n// our array to be modified.\nconst ADMIN_USER_IDS = ["0", "7365420", "257342015"] as const;\n\nfunction isAdmin(userId: string) {\n  return ADMIN_USER_IDS.includes(userId);\n}\n\n// Duration of 24 hours in milliseconds\nconst oneDay = 24 * 60 * 60 * 1000;\n')))}p.isMDXComponent=!0}}]);